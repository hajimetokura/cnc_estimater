<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNC åŠ å·¥è¦‹ç©ã‚‚ã‚Šãƒ„ãƒ¼ãƒ« v1.0</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        /* ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰ */
        :root, [data-theme="dark"] {
            --primary: #0f766e;
            --primary-light: #14b8a6;
            --primary-dark: #0d5a54;
            --accent: #f97316;
            --accent-light: #fb923c;
            --bg-body: #0f172a;
            --bg-header: linear-gradient(180deg, rgba(15, 23, 42, 0.98) 0%, rgba(15, 23, 42, 0.95) 100%);
            --bg-card: #1e293b;
            --bg-input: #334155;
            --bg-canvas: #1a1a2e;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border: #475569;
            --border-light: rgba(71, 85, 105, 0.5);
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --gradient-primary: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            --gradient-accent: linear-gradient(135deg, var(--accent) 0%, #fbbf24 100%);
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            --grid-color: rgba(71, 85, 105, 0.3);
            --entity-color: #14b8a6;
        }

        /* ãƒ©ã‚¤ãƒˆãƒ†ãƒ¼ãƒ */
        [data-theme="light"] {
            --primary: #0d9488;
            --primary-light: #14b8a6;
            --primary-dark: #0f766e;
            --accent: #ea580c;
            --accent-light: #f97316;
            --bg-body: #f8fafc;
            --bg-header: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
            --bg-card: #ffffff;
            --bg-input: #f1f5f9;
            --bg-canvas: #ffffff;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-muted: #94a3b8;
            --border: #e2e8f0;
            --border-light: rgba(226, 232, 240, 0.8);
            --success: #059669;
            --warning: #d97706;
            --error: #dc2626;
            --gradient-primary: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            --gradient-accent: linear-gradient(135deg, var(--accent) 0%, #f59e0b 100%);
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --grid-color: rgba(203, 213, 225, 0.5);
            --entity-color: #0d9488;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-body);
            color: var(--text-primary);
            height: 100vh;
            line-height: 1.6;
            overflow: hidden;
            transition: background 0.3s ease, color 0.3s ease;
        }

        /* ãƒ˜ãƒƒãƒ€ãƒ¼ */
        .header {
            background: var(--bg-header);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-light);
            padding: 12px 24px;
            position: sticky;
            top: 0;
            z-index: 100;
            flex-shrink: 0;
            transition: background 0.3s ease, border-color 0.3s ease;
        }

        .header-content {
            max-width: 1800px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: var(--gradient-primary);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            box-shadow: 0 4px 12px rgba(14, 165, 143, 0.3);
        }

        .logo-text h1 {
            font-size: 16px;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .logo-text span {
            font-size: 10px;
            color: var(--text-muted);
            font-weight: 400;
        }

        .header-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* ãƒ†ãƒ¼ãƒåˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ */
        .theme-toggle {
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 6px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .theme-toggle:hover {
            border-color: var(--primary);
            color: var(--primary-light);
        }

        .theme-toggle .icon {
            font-size: 14px;
        }

        [data-theme="light"] .theme-toggle {
            background: #fff;
            border-color: #e2e8f0;
        }

        /* ãƒ©ã‚¤ãƒˆãƒ†ãƒ¼ãƒè¿½åŠ èª¿æ•´ */
        [data-theme="light"] .toolbar-btn {
            background: #fff;
            border-color: #e2e8f0;
            color: #334155;
        }

        [data-theme="light"] .toolbar-btn:hover {
            background: #f1f5f9;
            border-color: var(--primary);
        }

        [data-theme="light"] .toolbar-btn.primary {
            color: #fff;
        }

        [data-theme="light"] .canvas-wrapper {
            background: #fff;
            border-color: #e2e8f0;
        }

        [data-theme="light"] .canvas-toolbar,
        [data-theme="light"] .canvas-status {
            background: rgba(248, 250, 252, 0.95);
            border-color: #e2e8f0;
        }

        [data-theme="light"] .drop-zone {
            background: rgba(248, 250, 252, 0.5);
            border-color: #cbd5e1;
        }

        [data-theme="light"] .drop-zone:hover {
            background: rgba(20, 184, 166, 0.05);
            border-color: var(--primary);
        }

        [data-theme="light"] .card-header {
            background: rgba(248, 250, 252, 0.8);
        }

        [data-theme="light"] .toolpath-item {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
        }

        [data-theme="light"] .estimate-result {
            background: linear-gradient(135deg, rgba(20, 184, 166, 0.08) 0%, rgba(248, 250, 252, 0.5) 100%);
            border-color: rgba(20, 184, 166, 0.2);
        }

        [data-theme="light"] .note {
            background: rgba(217, 119, 6, 0.08);
            border-color: rgba(217, 119, 6, 0.2);
        }

        [data-theme="light"] .preset-btn {
            background: #fff;
            border-color: #e2e8f0;
        }

        [data-theme="light"] .preset-btn.active {
            background: rgba(20, 184, 166, 0.1);
        }

        /* ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        .main-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px 24px;
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 20px;
            height: calc(100vh - 76px);
            overflow: hidden;
        }

        /* å·¦å´: ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¨ãƒªã‚¢ */
        .canvas-section {
            display: flex;
            flex-direction: column;
            gap: 16px;
            height: 100%;
            overflow: hidden;
        }

        .canvas-wrapper {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border);
            overflow: hidden;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .canvas-toolbar {
            background: rgba(30, 41, 59, 0.8);
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }

        .toolbar-left {
            display: flex;
            gap: 8px;
        }

        .toolbar-btn {
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 8px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toolbar-btn:hover {
            background: var(--primary-dark);
            border-color: var(--primary);
        }

        .toolbar-btn.primary {
            background: var(--gradient-primary);
            border: none;
        }

        .toolbar-btn.primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(14, 165, 143, 0.4);
        }

        #dxfCanvas {
            flex: 1;
            width: 100%;
            background: var(--bg-canvas);
            cursor: crosshair;
            transition: background 0.3s ease;
        }

        .canvas-status {
            background: rgba(30, 41, 59, 0.8);
            padding: 10px 16px;
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-muted);
            border-top: 1px solid var(--border);
        }

        /* ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‰ãƒ­ãƒƒãƒ—ã‚¨ãƒªã‚¢ */
        .drop-zone {
            border: 2px dashed var(--border);
            border-radius: 16px;
            padding: 60px 40px;
            text-align: center;
            transition: all 0.3s ease;
            background: rgba(30, 41, 59, 0.3);
            margin: 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--primary-light);
            background: rgba(14, 165, 143, 0.1);
        }

        .drop-zone-icon {
            font-size: 56px;
            margin-bottom: 16px;
            opacity: 0.7;
        }

        .drop-zone h3 {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .drop-zone p {
            color: var(--text-muted);
            font-size: 14px;
        }

        .drop-zone input {
            display: none;
        }

        /* å³å´: å…¥åŠ›ãƒ»çµæœãƒ‘ãƒãƒ« */
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 6px;
            padding-bottom: 40px;
        }

        .side-panel::-webkit-scrollbar {
            width: 6px;
        }

        .side-panel::-webkit-scrollbar-track {
            background: transparent;
        }

        .side-panel::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        .side-panel::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* ã‚«ãƒ¼ãƒ‰ */
        .card {
            background: var(--bg-card);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
            flex-shrink: 0;
            transition: background 0.3s ease, border-color 0.3s ease;
            box-shadow: var(--shadow);
        }

        [data-theme="light"] .card {
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .card-header {
            padding: 10px 14px;
            background: rgba(51, 65, 85, 0.3);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-header-icon {
            width: 24px;
            height: 24px;
            background: var(--gradient-primary);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .card-header h2 {
            font-size: 13px;
            font-weight: 600;
        }

        .card-body {
            padding: 12px 14px;
        }

        /* ãƒ„ãƒ¼ãƒ«ãƒ‘ã‚¹æƒ…å ± */
        .toolpath-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }

        .toolpath-item {
            background: var(--bg-input);
            border-radius: 6px;
            padding: 8px;
            text-align: center;
        }

        .toolpath-item .value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-weight: 600;
            color: var(--primary-light);
            margin-bottom: 1px;
        }

        .toolpath-item .label {
            font-size: 9px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .toolpath-item.full {
            grid-column: span 2;
        }

        /* ãƒ•ã‚©ãƒ¼ãƒ  */
        .form-group {
            margin-bottom: 10px;
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        .form-label {
            display: block;
            font-size: 10px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 3px;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .form-input, .form-select {
            width: 100%;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 7px 10px;
            font-size: 12px;
            color: var(--text-primary);
            font-family: inherit;
            transition: all 0.2s ease, background 0.3s ease;
        }

        [data-theme="light"] .form-input,
        [data-theme="light"] .form-select {
            border-color: #cbd5e1;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: var(--primary-light);
            box-shadow: 0 0 0 3px rgba(14, 165, 143, 0.2);
        }

        .form-input::placeholder {
            color: var(--text-muted);
        }

        .input-with-unit {
            position: relative;
        }

        .input-with-unit .form-input {
            padding-right: 40px;
        }

        .input-unit {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: var(--text-muted);
        }

        /* è¦‹ç©ã‚‚ã‚Šçµæœ */
        .estimate-result {
            background: linear-gradient(135deg, rgba(14, 165, 143, 0.15) 0%, rgba(15, 23, 42, 0.5) 100%);
            border: 1px solid rgba(14, 165, 143, 0.3);
        }

        .estimate-breakdown {
            margin-bottom: 10px;
        }

        .estimate-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(71, 85, 105, 0.5);
        }

        .estimate-row:last-child {
            border-bottom: none;
        }

        .estimate-row .label {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .estimate-row .value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 500;
        }

        .estimate-section-title {
            font-size: 9px;
            font-weight: 600;
            color: var(--primary-light);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 8px;
            margin-bottom: 4px;
            padding-bottom: 2px;
            border-bottom: 1px solid rgba(20, 184, 166, 0.3);
        }

        .estimate-section-title:first-child {
            margin-top: 0;
        }

        .estimate-row.subtotal {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px dashed rgba(71, 85, 105, 0.8);
            font-weight: 600;
        }

        .estimate-total {
            background: var(--gradient-accent);
            margin: -12px -14px;
            margin-top: 0;
            padding: 12px 14px;
        }

        .estimate-total .total-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 3px 0;
        }

        .estimate-total .total-row .label {
            font-size: 10px;
            opacity: 0.9;
        }

        .estimate-total .total-row .value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-weight: 600;
        }

        .estimate-total .total-row.tax-included .value {
            font-size: 22px;
            font-weight: 700;
        }

        /* ãƒœã‚¿ãƒ³ */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            font-family: inherit;
        }

        .btn-primary {
            background: var(--gradient-primary);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(14, 165, 143, 0.4);
        }

        .btn-accent {
            background: var(--gradient-accent);
            color: white;
        }

        .btn-accent:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(249, 115, 22, 0.4);
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-primary);
        }

        .btn-outline:hover {
            background: var(--bg-input);
            border-color: var(--primary);
        }

        .btn-block {
            width: 100%;
        }

        /* å˜ä¾¡ãƒ—ãƒªã‚»ãƒƒãƒˆ */
        .preset-group {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 6px;
        }

        .preset-btn {
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preset-btn:hover {
            border-color: var(--primary);
            color: var(--primary-light);
        }

        .preset-btn.active {
            background: var(--primary-dark);
            border-color: var(--primary);
            color: var(--primary-light);
        }

        /* æ³¨æ„æ›¸ã */
        .note {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 10px;
            color: var(--warning);
            display: flex;
            align-items: flex-start;
            gap: 6px;
            flex-shrink: 0;
            line-height: 1.4;
        }

        .note-icon {
            flex-shrink: 0;
        }

        /* ãƒ•ãƒƒã‚¿ãƒ¼ */
        .footer {
            text-align: center;
            padding: 16px;
            color: var(--text-muted);
            font-size: 11px;
            flex-shrink: 0;
        }

        /* å°åˆ·ç”¨è¦‹ç©æ›¸ */
        @media print {
            body {
                background: white;
                color: black;
            }
            .header, .canvas-section, .side-panel > .card:not(.estimate-result) {
                display: none;
            }
            .main-container {
                display: block;
            }
            .estimate-result {
                background: white;
                border: 2px solid black;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon">âš™ï¸</div>
                <div class="logo-text">
                    <h1>CNC åŠ å·¥è¦‹ç©ã‚‚ã‚Šãƒ„ãƒ¼ãƒ«</h1>
                    <span>DXFã‹ã‚‰ãƒ„ãƒ¼ãƒ«ãƒ‘ã‚¹ã‚’è¨ˆç®—ã—ã€æ¦‚ç®—è¦‹ç©ã‚‚ã‚Šã‚’ä½œæˆ</span>
                </div>
            </div>
            <div class="header-actions">
                <button class="theme-toggle" onclick="toggleTheme()" title="ãƒ†ãƒ¼ãƒåˆ‡ã‚Šæ›¿ãˆ">
                    <span class="icon" id="themeIcon">ğŸŒ™</span>
                    <span id="themeLabel">ãƒ€ãƒ¼ã‚¯</span>
                </button>
                <button class="toolbar-btn" onclick="exportEstimate()">
                    ğŸ“„ è¦‹ç©æ›¸å‡ºåŠ›
                </button>
                <button class="toolbar-btn" onclick="resetAll()">
                    ğŸ”„ ãƒªã‚»ãƒƒãƒˆ
                </button>
            </div>
        </div>
    </header>

    <main class="main-container">
        <!-- å·¦å´: ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¨ãƒªã‚¢ -->
        <section class="canvas-section">
            <div class="canvas-wrapper" id="canvasWrapper">
                <div class="canvas-toolbar">
                    <div class="toolbar-left">
                        <button class="toolbar-btn primary" onclick="document.getElementById('fileInput').click()">
                            ğŸ“ DXFã‚’é–‹ã
                        </button>
                        <input type="file" id="fileInput" accept=".dxf" style="display: none;">
                        <button class="toolbar-btn" onclick="zoomIn()">ğŸ” æ‹¡å¤§</button>
                        <button class="toolbar-btn" onclick="zoomOut()">ğŸ” ç¸®å°</button>
                        <button class="toolbar-btn" onclick="resetView()">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
                        <button class="toolbar-btn" onclick="toggleGrid()">âŠ ã‚°ãƒªãƒƒãƒ‰</button>
                    </div>
                    <div class="toolbar-right">
                        <span id="fileInfo" style="color: var(--text-muted); font-size: 13px;">ãƒ•ã‚¡ã‚¤ãƒ«æœªé¸æŠ</span>
                    </div>
                </div>
                
                <div class="drop-zone" id="dropZone">
                    <div class="drop-zone-icon">ğŸ“</div>
                    <h3>DXFãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—</h3>
                    <p>ã¾ãŸã¯ ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</p>
                    <input type="file" id="dropFileInput" accept=".dxf">
                </div>
                
                <canvas id="dxfCanvas" style="display: none;"></canvas>
                
                <div class="canvas-status" id="canvasStatus" style="display: none;">
                    <div>
                        <span id="zoomStatus">ã‚ºãƒ¼ãƒ : 100%</span>
                        <span style="margin-left: 16px;" id="entityCount">ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£: 0</span>
                    </div>
                    <div>
                        <span>ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«: ã‚ºãƒ¼ãƒ </span>
                        <span style="margin-left: 16px;">å³ãƒ‰ãƒ©ãƒƒã‚°: ãƒ‘ãƒ³</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- å³å´: å…¥åŠ›ãƒ»çµæœãƒ‘ãƒãƒ« -->
        <aside class="side-panel">
            <!-- ãƒ„ãƒ¼ãƒ«ãƒ‘ã‚¹æƒ…å ± -->
            <div class="card">
                <div class="card-header">
                    <div class="card-header-icon">ğŸ“Š</div>
                    <h2>ãƒ„ãƒ¼ãƒ«ãƒ‘ã‚¹æƒ…å ±</h2>
                </div>
                <div class="card-body">
                    <div class="toolpath-grid">
                        <div class="toolpath-item">
                            <div class="value" id="totalLength">0</div>
                            <div class="label">åˆ‡å‰Šç·é•· (mm)</div>
                        </div>
                        <div class="toolpath-item">
                            <div class="value" id="holeCount">0</div>
                            <div class="label">ç©´åŠ å·¥æ•°</div>
                        </div>
                        <div class="toolpath-item">
                            <div class="value" id="lineCount">0</div>
                            <div class="label">ç›´ç·šæ•°</div>
                        </div>
                        <div class="toolpath-item">
                            <div class="value" id="arcCount">0</div>
                            <div class="label">æ›²ç·šæ•°</div>
                        </div>
                        <div class="toolpath-item full">
                            <div class="value" id="boundingBox">0 Ã— 0</div>
                            <div class="label">ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ (mm)</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ç´ ææƒ…å ± -->
            <div class="card">
                <div class="card-header">
                    <div class="card-header-icon">ğŸªµ</div>
                    <h2>ç´ ææƒ…å ±</h2>
                </div>
                <div class="card-body">
                    <div class="form-group">
                        <label class="form-label">ç´ æç¨®é¡</label>
                        <select class="form-select" id="materialType" onchange="updateMaterialPreset(); calculateEstimate();">
                            <option value="lauan" selected>ãƒ©ãƒ¯ãƒ³åˆæ¿</option>
                            <option value="sina">ã‚·ãƒŠåˆæ¿</option>
                            <option value="clt">CLT</option>
                            <option value="mdf">MDF</option>
                            <option value="hinoki">ãƒ’ãƒã‚­</option>
                            <option value="sugi">ã‚¹ã‚®</option>
                            <option value="tamo">ã‚¿ãƒ¢</option>
                            <option value="nara">ãƒŠãƒ©</option>
                            <option value="custom">ã‚«ã‚¹ã‚¿ãƒ </option>
                        </select>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">æ¿åš</label>
                            <div class="input-with-unit">
                                <input type="number" class="form-input" id="thickness" value="5" min="0" step="0.1" oninput="calculateEstimate()">
                                <span class="input-unit">mm</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">ç´ æå˜ä¾¡</label>
                            <div class="input-with-unit">
                                <input type="number" class="form-input" id="materialPrice" value="3500" min="0" oninput="calculateEstimate()">
                                <span class="input-unit">å††/æš</span>
                            </div>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">ç´ æã‚µã‚¤ã‚ºï¼ˆç¸¦ï¼‰</label>
                            <div class="input-with-unit">
                                <input type="number" class="form-input" id="materialWidth" value="300" min="0" oninput="calculateEstimate()">
                                <span class="input-unit">mm</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">ç´ æã‚µã‚¤ã‚ºï¼ˆæ¨ªï¼‰</label>
                            <div class="input-with-unit">
                                <input type="number" class="form-input" id="materialHeight" value="300" min="0" oninput="calculateEstimate()">
                                <span class="input-unit">mm</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- åŠ å·¥å˜ä¾¡ -->
            <div class="card">
                <div class="card-header">
                    <div class="card-header-icon">ğŸ’°</div>
                    <h2>åŠ å·¥å˜ä¾¡</h2>
                </div>
                <div class="card-body">
                    <div class="form-group">
                        <label class="form-label">CNCåŠ å·¥è²»ï¼ˆã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼äººä»¶è²»è¾¼ï¼‰</label>
                        <div class="input-with-unit">
                            <input type="number" class="form-input" id="cncHourlyRate" value="8700" min="0" oninput="calculateEstimate()">
                            <span class="input-unit">å††/æ™‚é–“</span>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">åŠ å·¥ãƒ‡ãƒ¼ã‚¿ä½œæˆè²»</label>
                            <div class="input-with-unit">
                                <input type="number" class="form-input" id="camCost" value="33400" min="0" oninput="calculateEstimate()">
                                <span class="input-unit">å††/äººå·¥</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—è²»</label>
                            <div class="input-with-unit">
                                <input type="number" class="form-input" id="setupCost" value="5000" min="0" oninput="calculateEstimate()">
                                <span class="input-unit">å††</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- äººå·¥æ•° -->
            <div class="card">
                <div class="card-header">
                    <div class="card-header-icon">ğŸ‘·</div>
                    <h2>åˆ¶ä½œäººå·¥æ•°</h2>
                </div>
                <div class="card-body">
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">CNCåŠ å·¥æ™‚é–“</label>
                            <div class="input-with-unit">
                                <input type="number" class="form-input" id="machiningTime" value="1" min="0" step="0.5" oninput="calculateEstimate()">
                                <span class="input-unit">æ™‚é–“</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">CAMä½œæˆ</label>
                            <div class="input-with-unit">
                                <input type="number" class="form-input" id="camManDays" value="0.5" min="0" step="0.1" oninput="calculateEstimate()">
                                <span class="input-unit">äººå·¥</span>
                            </div>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">ä»•ä¸Šã’ï¼ˆãƒãƒªå–ã‚Šç ”ç£¨ï¼‰</label>
                            <div class="input-with-unit">
                                <input type="number" class="form-input" id="finishingManDays" value="1" min="0" step="0.5" oninput="calculateEstimate()">
                                <span class="input-unit">äººå·¥</span>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">ä»•ä¸Šã’å˜ä¾¡</label>
                            <div class="input-with-unit">
                                <input type="number" class="form-input" id="finishingRate" value="28000" min="0" oninput="calculateEstimate()">
                                <span class="input-unit">å††/äººå·¥</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- è¦‹ç©ã‚‚ã‚Šçµæœ -->
            <div class="card estimate-result">
                <div class="card-header">
                    <div class="card-header-icon" style="background: var(--gradient-accent);">ğŸ“‹</div>
                    <h2>æ¦‚ç®—è¦‹ç©ã‚‚ã‚Š</h2>
                </div>
                <div class="card-body">
                    <div class="estimate-breakdown">
                        <div class="estimate-section-title">ææ–™è²»</div>
                        <div class="estimate-row">
                            <span class="label">ç´ æè²»</span>
                            <span class="value" id="materialCost">Â¥0</span>
                        </div>
                        <div class="estimate-section-title">CNCåŠ å·¥è²»</div>
                        <div class="estimate-row">
                            <span class="label">åˆ‡å‰ŠåŠ å·¥è²»</span>
                            <span class="value" id="cncCost">Â¥0</span>
                        </div>
                        <div class="estimate-row">
                            <span class="label">åŠ å·¥ãƒ‡ãƒ¼ã‚¿ä½œæˆè²»</span>
                            <span class="value" id="camDataCost">Â¥0</span>
                        </div>
                        <div class="estimate-section-title">äººä»¶è²»</div>
                        <div class="estimate-row">
                            <span class="label">ä»•ä¸Šã’è²»ï¼ˆãƒãƒªå–ã‚Šç ”ç£¨ï¼‰</span>
                            <span class="value" id="finishingCost">Â¥0</span>
                        </div>
                        <div class="estimate-row">
                            <span class="label">ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—è²»</span>
                            <span class="value" id="setupCostDisplay">Â¥0</span>
                        </div>
                        <div class="estimate-row subtotal">
                            <span class="label">å°è¨ˆï¼ˆç¨åˆ¥ï¼‰</span>
                            <span class="value" id="subtotalDisplay">Â¥0</span>
                        </div>
                    </div>
                    <div class="estimate-total">
                        <div class="total-row">
                            <span class="label">ç¨åˆ¥</span>
                            <span class="value" id="totalEstimate">Â¥0</span>
                        </div>
                        <div class="total-row tax-included">
                            <span class="label">ç¨è¾¼</span>
                            <span class="value" id="totalWithTax">Â¥0</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="note">
                <span class="note-icon">âš ï¸</span>
                <span>ã“ã®è¦‹ç©ã‚‚ã‚Šã¯æ¦‚ç®—ã§ã™ã€‚è©³ç´°è¨­è¨ˆã«ã‚ˆã‚Šé‡‘é¡ãŒå¤‰å‹•ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</span>
            </div>
        </aside>
    </main>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let currentEntities = [];
        let zoomLevel = 1.0;
        let panX = 0;
        let panY = 0;
        let showGrid = true;
        let currentScale = 1;
        let currentOffsetX = 0;
        let currentOffsetY = 0;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let currentFilename = '';
        let currentTheme = 'dark';

        // ãƒ†ãƒ¼ãƒåˆ‡ã‚Šæ›¿ãˆ
        function toggleTheme() {
            currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', currentTheme);
            
            // ã‚¢ã‚¤ã‚³ãƒ³ã¨ãƒ©ãƒ™ãƒ«ã‚’æ›´æ–°
            const icon = document.getElementById('themeIcon');
            const label = document.getElementById('themeLabel');
            if (currentTheme === 'dark') {
                icon.textContent = 'ğŸŒ™';
                label.textContent = 'ãƒ€ãƒ¼ã‚¯';
            } else {
                icon.textContent = 'â˜€ï¸';
                label.textContent = 'ãƒ©ã‚¤ãƒˆ';
            }
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
            localStorage.setItem('cnc-estimator-theme', currentTheme);
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’å†æç”»
            if (currentEntities.length > 0) {
                drawDXF();
            }
        }

        // ãƒ†ãƒ¼ãƒã®åˆæœŸåŒ–
        function initTheme() {
            const savedTheme = localStorage.getItem('cnc-estimator-theme');
            if (savedTheme) {
                currentTheme = savedTheme;
                document.documentElement.setAttribute('data-theme', currentTheme);
                const icon = document.getElementById('themeIcon');
                const label = document.getElementById('themeLabel');
                if (currentTheme === 'light') {
                    icon.textContent = 'â˜€ï¸';
                    label.textContent = 'ãƒ©ã‚¤ãƒˆ';
                }
            }
        }

        // ãƒ„ãƒ¼ãƒ«ãƒ‘ã‚¹æƒ…å ±
        let toolpathInfo = {
            totalLength: 0,
            holeCount: 0,
            lineCount: 0,
            arcCount: 0,
            boundingBox: { minX: 0, maxX: 0, minY: 0, maxY: 0 }
        };

        // Bulgeï¼ˆè†¨ã‚‰ã¿ï¼‰ã‚’å«ã‚€å††å¼§ãƒã‚¤ãƒ³ãƒˆç”Ÿæˆ
        function generateArcPoints(pointsArray, start, end, bulge) {
            const startPoint = { x: start.x, y: start.y };
            const endPoint = { x: end.x, y: end.y };
            if (pointsArray.length === 0) {
                pointsArray.push(startPoint);
            }
            const b = bulge || 0;
            if (Math.abs(b) < 1e-8) {
                pointsArray.push(endPoint);
                return;
            }
            const dx = endPoint.x - startPoint.x;
            const dy = endPoint.y - startPoint.y;
            const chord = Math.hypot(dx, dy);
            if (chord === 0) return;
            const theta = 4 * Math.atan(b);
            const sinHalf = Math.sin(theta / 2);
            if (Math.abs(sinHalf) < 1e-8) {
                pointsArray.push(endPoint);
                return;
            }
            const radius = chord / (2 * sinHalf);
            const absRadius = Math.abs(radius);
            const midX = (startPoint.x + endPoint.x) / 2;
            const midY = (startPoint.y + endPoint.y) / 2;
            const ux = dx / chord;
            const uy = dy / chord;
            const perpX = -uy;
            const perpY = ux;
            const h = Math.sqrt(Math.max(0, absRadius * absRadius - (chord / 2) * (chord / 2)));
            const direction = theta > 0 ? 1 : -1;
            const centerX = midX + perpX * h * direction;
            const centerY = midY + perpY * h * direction;
            const startAngle = Math.atan2(startPoint.y - centerY, startPoint.x - centerX);
            const segments = Math.max(8, Math.ceil(Math.abs(theta) / (Math.PI / 18)));
            for (let i = 1; i <= segments; i++) {
                const angle = startAngle + (theta / segments) * i;
                pointsArray.push({
                    x: centerX + Math.cos(angle) * absRadius,
                    y: centerY + Math.sin(angle) * absRadius
                });
            }
        }

        // ãƒãƒªãƒ©ã‚¤ãƒ³ã®é ‚ç‚¹ã‚’å±•é–‹ï¼ˆbulgeå¯¾å¿œï¼‰
        function expandPolylinePoints(vertices, closed) {
            if (!vertices || vertices.length === 0) return [];
            const raw = vertices
                .filter(v => v.x !== undefined && v.y !== undefined)
                .map(v => ({ x: v.x, y: v.y, bulge: v.bulge || 0 }));
            if (raw.length === 0) return [];
            const result = [];
            const count = raw.length;
            const segments = closed ? count : count - 1;
            for (let i = 0; i < segments; i++) {
                const current = raw[i];
                const next = raw[(i + 1) % count];
                generateArcPoints(result, current, next, current.bulge || 0);
            }
            if (!closed) {
                const last = raw[raw.length - 1];
                result.push({ x: last.x, y: last.y });
            }
            return result;
        }

        // Bã‚¹ãƒ—ãƒ©ã‚¤ãƒ³è©•ä¾¡ï¼ˆde Boorã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼‰
        function evaluateBSpline(controlPoints, knots, degree, u) {
            const n = controlPoints.length;
            if (n < degree + 1 || !knots || knots.length === 0) return null;
            
            let span = -1;
            for (let i = degree; i < knots.length - degree - 1; i++) {
                if (u >= knots[i] && u <= knots[i + 1]) {
                    span = i;
                    break;
                }
            }
            
            if (span === -1 && u >= knots[knots.length - degree - 1]) {
                span = knots.length - degree - 2;
            }
            
            if (span === -1) return null;
            
            const p = degree;
            const d = [];
            
            for (let i = 0; i <= p; i++) {
                let idx = span - p + i;
                idx = Math.max(0, Math.min(n - 1, idx));
                d.push({ x: controlPoints[idx].x, y: controlPoints[idx].y });
            }
            
            for (let r = 1; r <= p; r++) {
                for (let j = p; j >= r; j--) {
                    const i = span - p + j;
                    const alpha_num = u - knots[i];
                    const alpha_den = knots[i + p - r + 1] - knots[i];
                    
                    if (Math.abs(alpha_den) < 1e-10) continue;
                    
                    const alpha = alpha_num / alpha_den;
                    d[j].x = (1 - alpha) * d[j - 1].x + alpha * d[j].x;
                    d[j].y = (1 - alpha) * d[j - 1].y + alpha * d[j].y;
                }
            }
            
            return d[p];
        }
        
        // Bã‚¹ãƒ—ãƒ©ã‚¤ãƒ³æ›²ç·šã‚’ç”Ÿæˆ
        function generateBSplinePoints(controlPoints, knots, degree, closed = false, periodic = false, numPoints = 400) {
            if (!controlPoints || controlPoints.length < degree + 1) return [];
            
            let workControlPoints = controlPoints;
            let workKnots = knots;
            
            const expectedKnots = workControlPoints.length + degree + 1;
            const hasCorrectKnots = workKnots && workKnots.length === expectedKnots;
            
            if (!hasCorrectKnots && closed && periodic && workControlPoints.length > degree + 1) {
                const first = workControlPoints[0];
                const last = workControlPoints[workControlPoints.length - 1];
                const dist = Math.sqrt(Math.pow(last.x - first.x, 2) + Math.pow(last.y - first.y, 2));
                if (dist < 0.001) {
                    workControlPoints = workControlPoints.slice(0, -1);
                }
            }
            
            if (!workKnots || workKnots.length < (degree + 1) * 2) {
                const n = workControlPoints.length;
                workKnots = [];
                for (let i = 0; i < degree + 1; i++) workKnots.push(0);
                for (let i = 1; i < n - degree; i++) workKnots.push(i);
                for (let i = 0; i < degree + 1; i++) workKnots.push(n - degree);
            }
            
            const knotMin = workKnots[degree];
            const knotMax = workKnots[workKnots.length - degree - 1];
            
            if (knotMax <= knotMin) return [];
            
            const result = [];
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const u = knotMin + t * (knotMax - knotMin);
                const point = evaluateBSpline(workControlPoints, workKnots, degree, u);
                if (point && isFinite(point.x) && isFinite(point.y)) {
                    result.push(point);
                }
            }
            
            if (closed && result.length > 1) {
                const first = result[0];
                const last = result[result.length - 1];
                const dist = Math.sqrt(Math.pow(last.x - first.x, 2) + Math.pow(last.y - first.y, 2));
                if (dist > 0.5) {
                    result.push({ x: first.x, y: first.y });
                }
            }
            
            return result;
        }
        
        // Catmull-Rom ã‚¹ãƒ—ãƒ©ã‚¤ãƒ³è£œé–“
        function generateCatmullRomPoints(points, segmentsPerSpan = 32, closed = false) {
            if (!points || points.length < 2) return points || [];
            
            const result = [];
            const n = points.length;
            
            let extendedPoints = points;
            if (closed && n >= 3) {
                extendedPoints = [points[n - 2], points[n - 1], ...points, points[0], points[1]];
            }
            
            const extN = extendedPoints.length;
            const startIdx = closed ? 2 : 0;
            const endIdx = closed ? extN - 2 : extN - 1;
            
            for (let i = startIdx; i < endIdx; i++) {
                const p0 = extendedPoints[i - 1] || extendedPoints[i];
                const p1 = extendedPoints[i];
                const p2 = extendedPoints[i + 1] || extendedPoints[i];
                const p3 = extendedPoints[i + 2] || extendedPoints[i + 1] || extendedPoints[i];
                
                for (let j = 0; j < segmentsPerSpan; j++) {
                    const t = j / segmentsPerSpan;
                    const t2 = t * t;
                    const t3 = t2 * t;
                    
                    const x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3);
                    const y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3);
                    
                    result.push({ x, y });
                }
            }
            
            if (closed && result.length > 0) {
                result.push({ x: points[0].x, y: points[0].y });
            } else {
                result.push(points[n - 1]);
            }
            
            return result;
        }

        // ç´ æå¯†åº¦ (g/cmÂ³)
        const materialDensity = {
            lauan: 0.55,      // ãƒ©ãƒ¯ãƒ³åˆæ¿
            sina: 0.45,       // ã‚·ãƒŠåˆæ¿
            clt: 0.50,        // CLT
            mdf: 0.75,        // MDF
            hinoki: 0.44,     // ãƒ’ãƒã‚­
            sugi: 0.38,       // ã‚¹ã‚®
            tamo: 0.65,       // ã‚¿ãƒ¢
            nara: 0.70,       // ãƒŠãƒ©
            custom: 0.55
        };

        // ç´ æå˜ä¾¡ãƒ—ãƒªã‚»ãƒƒãƒˆ (å††/æš - 3x6æ¿æƒ³å®š)
        const materialPricePreset = {
            lauan: 3500,      // ãƒ©ãƒ¯ãƒ³åˆæ¿
            sina: 5500,       // ã‚·ãƒŠåˆæ¿
            clt: 15000,       // CLT
            mdf: 2500,        // MDF
            hinoki: 12000,    // ãƒ’ãƒã‚­
            sugi: 8000,       // ã‚¹ã‚®
            tamo: 18000,      // ã‚¿ãƒ¢
            nara: 22000,      // ãƒŠãƒ©
            custom: 5000
        };

        // ç´ æåç§°
        const materialNames = {
            lauan: 'ãƒ©ãƒ¯ãƒ³åˆæ¿',
            sina: 'ã‚·ãƒŠåˆæ¿',
            clt: 'CLT',
            mdf: 'MDF',
            hinoki: 'ãƒ’ãƒã‚­',
            sugi: 'ã‚¹ã‚®',
            tamo: 'ã‚¿ãƒ¢',
            nara: 'ãƒŠãƒ©',
            custom: 'ã‚«ã‚¹ã‚¿ãƒ '
        };

        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            initTheme();
            setupDragAndDrop();
            setupFileInput();
            setupCanvas();
            calculateEstimate();
        });

        // ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—è¨­å®š
        function setupDragAndDrop() {
            const dropZone = document.getElementById('dropZone');
            const dropInput = document.getElementById('dropFileInput');

            dropZone.addEventListener('click', () => dropInput.click());
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.name.toLowerCase().endsWith('.dxf')) {
                    loadFile(file);
                }
            });

            dropInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) loadFile(file);
            });
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›è¨­å®š
        function setupFileInput() {
            document.getElementById('fileInput').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) loadFile(file);
            });
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
        function loadFile(file) {
            currentFilename = file.name;
            const reader = new FileReader();
            reader.onload = (event) => {
                parseDXF(event.target.result, file.name);
            };
            reader.readAsText(file);
        }

        // DXFãƒ‘ãƒ¼ã‚¹ï¼ˆå®Œå…¨ç‰ˆï¼‰
        function parseDXF(content, filename) {
            console.log('=== DXFè§£æé–‹å§‹ ===');
            const lines = content.split('\n').map(l => l.trim());
            
            const entities = [];
            const layers = new Set();
            const blocks = {};
            
            let i = 0;
            let blocksStart = -1;
            let blocksEnd = -1;
            let entitiesStart = -1;
            
            // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ä½ç½®ã‚’ç‰¹å®š
            while (i < lines.length) {
                if (lines[i] === '0' && lines[i + 1] === 'SECTION') {
                    const sectionName = lines[i + 3];
                    if (sectionName === 'BLOCKS') blocksStart = i + 4;
                    else if (sectionName === 'ENTITIES') entitiesStart = i + 4;
                }
                if (lines[i] === '0' && lines[i + 1] === 'ENDSEC') {
                    if (blocksStart !== -1 && blocksEnd === -1 && entitiesStart === -1) {
                        blocksEnd = i;
                    }
                }
                i++;
            }
            
            // BLOCKSã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è§£æ
            if (blocksStart !== -1 && blocksEnd !== -1) {
                let currentBlock = null;
                let currentEntity = null;
                let groupCode = null;
                let vertexMode = false;
                
                for (let j = blocksStart; j < blocksEnd; j++) {
                    const line = lines[j];
                    
                    if (groupCode === null) {
                        if (line === '') continue;
                        groupCode = parseInt(line);
                        continue;
                    }
                    
                    const value = line;
                    
                    if (groupCode === 0) {
                        if (value === 'BLOCK') {
                            if (currentEntity && currentBlock) currentBlock.entities.push(currentEntity);
                            currentBlock = { name: '', entities: [], basePoint: { x: 0, y: 0 } };
                            currentEntity = null;
                        } else if (value === 'ENDBLK') {
                            if (currentEntity && currentBlock) currentBlock.entities.push(currentEntity);
                            if (currentBlock && currentBlock.name && !currentBlock.name.startsWith('*')) {
                                blocks[currentBlock.name] = currentBlock;
                            }
                            currentBlock = null;
                            currentEntity = null;
                        } else if (currentBlock && ['LINE', 'ARC', 'CIRCLE', 'POLYLINE', 'LWPOLYLINE', 'SPLINE'].includes(value)) {
                            if (currentEntity) currentBlock.entities.push(currentEntity);
                            currentEntity = { type: value, layer: '0', color: 1, points: [], vertices: [] };
                            vertexMode = false;
                        } else if (value === 'VERTEX') {
                            vertexMode = true;
                            if (currentEntity && !currentEntity.vertices) currentEntity.vertices = [];
                            if (currentEntity) currentEntity.vertices.push({});
                        } else if (value === 'SEQEND') {
                            vertexMode = false;
                        }
                    } else if (groupCode === 2 && currentBlock && !currentBlock.name) {
                        currentBlock.name = value;
                    } else if (groupCode === 10 && currentBlock && !currentEntity) {
                        currentBlock.basePoint.x = parseFloat(value);
                    } else if (groupCode === 20 && currentBlock && !currentEntity) {
                        currentBlock.basePoint.y = parseFloat(value);
                    } else if (currentEntity) {
                        if (vertexMode && currentEntity.vertices && currentEntity.vertices.length > 0) {
                            const lastVertex = currentEntity.vertices[currentEntity.vertices.length - 1];
                            if (groupCode === 10) lastVertex.x = parseFloat(value);
                            else if (groupCode === 20) lastVertex.y = parseFloat(value);
                            else if (groupCode === 42) lastVertex.bulge = parseFloat(value);
                        } else if (currentEntity.type === 'LWPOLYLINE') {
                            if (groupCode === 10) {
                                if (!currentEntity.points) currentEntity.points = [];
                                currentEntity.points.push({ x: parseFloat(value), y: undefined, bulge: 0 });
                            } else if (groupCode === 20 && currentEntity.points && currentEntity.points.length > 0) {
                                currentEntity.points[currentEntity.points.length - 1].y = parseFloat(value);
                            } else if (groupCode === 42 && currentEntity.points && currentEntity.points.length > 0) {
                                currentEntity.points[currentEntity.points.length - 1].bulge = parseFloat(value);
                            } else if (groupCode === 8) currentEntity.layer = value;
                            else if (groupCode === 62) currentEntity.color = parseInt(value);
                            else if (groupCode === 70) {
                                currentEntity.flags = parseInt(value);
                                currentEntity.closed = (parseInt(value) & 1) === 1;
                            }
                        } else {
                            if (groupCode === 8) currentEntity.layer = value;
                            else if (groupCode === 62) currentEntity.color = parseInt(value);
                            else if (groupCode === 10) currentEntity.x1 = parseFloat(value);
                            else if (groupCode === 20) currentEntity.y1 = parseFloat(value);
                            else if (groupCode === 11) currentEntity.x2 = parseFloat(value);
                            else if (groupCode === 21) currentEntity.y2 = parseFloat(value);
                            else if (groupCode === 40) currentEntity.radius = parseFloat(value);
                            else if (groupCode === 50) currentEntity.startAngle = parseFloat(value);
                            else if (groupCode === 51) currentEntity.endAngle = parseFloat(value);
                            else if (groupCode === 70) {
                                currentEntity.flags = parseInt(value);
                                currentEntity.closed = (parseInt(value) & 1) === 1;
                            }
                        }
                    }
                    
                    groupCode = null;
                }
            }
            
            if (entitiesStart === -1) {
                alert('ENTITIESã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return;
            }
            
            // ENTITIESã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è§£æ
            i = entitiesStart;
            let currentEntity = null;
            let groupCode = null;
            let vertexMode = false;
            
            while (i < lines.length) {
                const line = lines[i];
                
                if (groupCode === null) {
                    if (line === '') { i++; continue; }
                    groupCode = parseInt(line);
                    i++;
                    continue;
                }
                
                const value = line;
                
                if (groupCode === 0) {
                    if (value === 'ENDSEC') {
                        if (currentEntity) entities.push(currentEntity);
                        break;
                    }
                    
                    if (value === 'VERTEX') {
                        vertexMode = true;
                        if (!currentEntity.vertices) currentEntity.vertices = [];
                        currentEntity.vertices.push({});
                    } else if (value === 'SEQEND') {
                        vertexMode = false;
                    } else {
                        if (currentEntity) entities.push(currentEntity);
                        currentEntity = { type: value, layer: '0', color: 1, points: [], vertices: [] };
                        vertexMode = false;
                    }
                }
                else if (vertexMode && currentEntity && currentEntity.vertices.length > 0) {
                    const lastVertex = currentEntity.vertices[currentEntity.vertices.length - 1];
                    if (groupCode === 10) lastVertex.x = parseFloat(value);
                    else if (groupCode === 20) lastVertex.y = parseFloat(value);
                    else if (groupCode === 30) lastVertex.z = parseFloat(value);
                    else if (groupCode === 42) lastVertex.bulge = parseFloat(value);
                    else if (groupCode === 70) lastVertex.flags = parseInt(value);
                }
                else if (groupCode === 8 && currentEntity) {
                    currentEntity.layer = value;
                    layers.add(value);
                }
                else if (groupCode === 62 && currentEntity) {
                    currentEntity.color = parseInt(value);
                }
                else if (groupCode === 70 && currentEntity) {
                    currentEntity.flags = parseInt(value);
                    const flags = parseInt(value);
                    currentEntity.closed = (flags & 1) === 1;
                    currentEntity.periodic = (flags & 2) === 2;
                    currentEntity.rational = (flags & 4) === 4;
                }
                else if (groupCode === 90 && currentEntity && currentEntity.type === 'LWPOLYLINE') {
                    currentEntity.vertexCount = parseInt(value);
                }
                else if (groupCode === 71 && currentEntity && currentEntity.type === 'SPLINE') {
                    currentEntity.degree = parseInt(value);
                }
                else if (currentEntity && currentEntity.type === 'INSERT') {
                    if (groupCode === 2) currentEntity.blockName = value;
                    else if (groupCode === 10) currentEntity.insertX = parseFloat(value);
                    else if (groupCode === 20) currentEntity.insertY = parseFloat(value);
                    else if (groupCode === 41) currentEntity.scaleX = parseFloat(value);
                    else if (groupCode === 42) currentEntity.scaleY = parseFloat(value);
                    else if (groupCode === 50) currentEntity.rotation = parseFloat(value);
                }
                else if (currentEntity) {
                    if (currentEntity.type === 'SPLINE') {
                        if (!currentEntity.controlPoints) currentEntity.controlPoints = [];
                        if (!currentEntity.fitPoints) currentEntity.fitPoints = [];
                        if (!currentEntity.knots) currentEntity.knots = [];
                        
                        if (groupCode === 40) {
                            currentEntity.knots.push(parseFloat(value));
                        } else if (groupCode === 10) {
                            currentEntity._pendingCtrl = currentEntity._pendingCtrl || {};
                            currentEntity._pendingCtrl.x = parseFloat(value);
                        } else if (groupCode === 20) {
                            currentEntity._pendingCtrl = currentEntity._pendingCtrl || {};
                            currentEntity._pendingCtrl.y = parseFloat(value);
                            if (currentEntity._pendingCtrl.x !== undefined) {
                                currentEntity.controlPoints.push({ x: currentEntity._pendingCtrl.x, y: currentEntity._pendingCtrl.y });
                                currentEntity._pendingCtrl = {};
                            }
                        } else if (groupCode === 11) {
                            currentEntity._pendingFit = currentEntity._pendingFit || {};
                            currentEntity._pendingFit.x = parseFloat(value);
                        } else if (groupCode === 21) {
                            currentEntity._pendingFit = currentEntity._pendingFit || {};
                            currentEntity._pendingFit.y = parseFloat(value);
                            if (currentEntity._pendingFit.x !== undefined) {
                                currentEntity.fitPoints.push({ x: currentEntity._pendingFit.x, y: currentEntity._pendingFit.y });
                                currentEntity._pendingFit = {};
                            }
                        }
                    } else if (currentEntity.type === 'LWPOLYLINE') {
                        if (groupCode === 10) {
                            currentEntity._pendingLwVertex = currentEntity._pendingLwVertex || {};
                            currentEntity._pendingLwVertex.x = parseFloat(value);
                        } else if (groupCode === 20) {
                            currentEntity._pendingLwVertex = currentEntity._pendingLwVertex || {};
                            currentEntity._pendingLwVertex.y = parseFloat(value);
                            if (currentEntity._pendingLwVertex.x !== undefined) {
                                const vertex = {
                                    x: currentEntity._pendingLwVertex.x,
                                    y: currentEntity._pendingLwVertex.y,
                                    bulge: currentEntity._pendingLwVertex.bulge || 0
                                };
                                currentEntity.points.push(vertex);
                                currentEntity._pendingLwVertex = {};
                            }
                        } else if (groupCode === 42) {
                            const bulgeValue = parseFloat(value);
                            currentEntity._pendingLwVertex = currentEntity._pendingLwVertex || {};
                            const hasPendingCoords = currentEntity._pendingLwVertex.x !== undefined || currentEntity._pendingLwVertex.y !== undefined;
                            if (hasPendingCoords) {
                                currentEntity._pendingLwVertex.bulge = bulgeValue;
                            } else if (currentEntity.points.length > 0) {
                                currentEntity.points[currentEntity.points.length - 1].bulge = bulgeValue;
                            }
                        }
                    } else {
                        if (groupCode === 10) currentEntity.x1 = parseFloat(value);
                        else if (groupCode === 20) currentEntity.y1 = parseFloat(value);
                        else if (groupCode === 11) currentEntity.x2 = parseFloat(value);
                        else if (groupCode === 21) currentEntity.y2 = parseFloat(value);
                        else if (groupCode === 40) currentEntity.radius = parseFloat(value);
                        else if (groupCode === 50) currentEntity.startAngle = parseFloat(value);
                        else if (groupCode === 51) currentEntity.endAngle = parseFloat(value);
                        else if (groupCode === 210) currentEntity.extrusionX = parseFloat(value);
                        else if (groupCode === 220) currentEntity.extrusionY = parseFloat(value);
                        else if (groupCode === 230) currentEntity.extrusionZ = parseFloat(value);
                    }
                }
                
                groupCode = null;
                i++;
            }
            
            if (currentEntity) entities.push(currentEntity);
            
            // INSERTã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’å±•é–‹
            const expandedEntities = [];
            entities.forEach(e => {
                if (e.type === 'INSERT' && e.blockName && blocks[e.blockName]) {
                    const block = blocks[e.blockName];
                    const insertX = e.insertX || 0;
                    const insertY = e.insertY || 0;
                    const scaleX = e.scaleX || 1;
                    const scaleY = e.scaleY || 1;
                    const rotation = (e.rotation || 0) * Math.PI / 180;
                    
                    block.entities.forEach(blockEntity => {
                        const newEntity = JSON.parse(JSON.stringify(blockEntity));
                        
                        const transformPoint = (x, y) => {
                            const rx = x - block.basePoint.x;
                            const ry = y - block.basePoint.y;
                            const sx = rx * scaleX;
                            const sy = ry * scaleY;
                            const cos = Math.cos(rotation);
                            const sin = Math.sin(rotation);
                            const rotX = sx * cos - sy * sin;
                            const rotY = sx * sin + sy * cos;
                            return { x: rotX + insertX, y: rotY + insertY };
                        };
                        
                        if (newEntity.x1 !== undefined && newEntity.y1 !== undefined) {
                            const p1 = transformPoint(newEntity.x1, newEntity.y1);
                            newEntity.x1 = p1.x;
                            newEntity.y1 = p1.y;
                        }
                        if (newEntity.x2 !== undefined && newEntity.y2 !== undefined) {
                            const p2 = transformPoint(newEntity.x2, newEntity.y2);
                            newEntity.x2 = p2.x;
                            newEntity.y2 = p2.y;
                        }
                        if (newEntity.radius !== undefined) {
                            newEntity.radius = newEntity.radius * Math.abs(scaleX);
                        }
                        if (newEntity.vertices) {
                            newEntity.vertices = newEntity.vertices.map(v => {
                                if (v.x !== undefined && v.y !== undefined) {
                                    const p = transformPoint(v.x, v.y);
                                    return { ...v, x: p.x, y: p.y };
                                }
                                return v;
                            });
                        }
                        if (newEntity.points && newEntity.points.length > 0) {
                            newEntity.points = newEntity.points.map(p => {
                                if (p.x !== undefined && p.y !== undefined) {
                                    const tp = transformPoint(p.x, p.y);
                                    return { ...p, x: tp.x, y: tp.y };
                                }
                                return p;
                            });
                        }
                        
                        if (e.layer !== '0') newEntity.layer = e.layer;
                        expandedEntities.push(newEntity);
                    });
                } else if (e.type !== 'INSERT') {
                    expandedEntities.push(e);
                }
            });
            
            entities.length = 0;
            expandedEntities.forEach(e => entities.push(e));
            
            // OCSâ†’WCSå¤‰æ›
            entities.forEach(e => {
                if ((e.type === 'ARC' || e.type === 'CIRCLE') && e.extrusionZ !== undefined && e.extrusionZ < 0) {
                    if (e.x1 !== undefined) e.x1 = -e.x1;
                    if (e.type === 'ARC') {
                        const origStart = e.startAngle;
                        const origEnd = e.endAngle;
                        e.startAngle = 180 - origEnd;
                        e.endAngle = 180 - origStart;
                        while (e.startAngle < 0) e.startAngle += 360;
                        while (e.endAngle < 0) e.endAngle += 360;
                    }
                }
            });
            
            // POLYLINE/LWPOLYLINE/SPLINEã®ç‚¹ã‚’å±•é–‹
            entities.forEach(e => {
                if (e.type === 'POLYLINE' && e.vertices && e.vertices.length > 0) {
                    e.points = expandPolylinePoints(e.vertices, e.closed);
                }
                
                if (e.type === 'LWPOLYLINE' && e.points && e.points.length > 0) {
                    e.points = expandPolylinePoints(e.points, e.closed);
                }
                
                if (e.type === 'SPLINE') {
                    const degree = e.degree || 3;
                    const isClosed = e.closed || false;
                    const isPeriodic = e.periodic || false;
                    
                    if (e.fitPoints && e.fitPoints.length >= 2) {
                        let cleanPoints = e.fitPoints;
                        if (isClosed && cleanPoints.length > 2) {
                            const first = cleanPoints[0];
                            const last = cleanPoints[cleanPoints.length - 1];
                            const dist = Math.sqrt(Math.pow(last.x - first.x, 2) + Math.pow(last.y - first.y, 2));
                            if (dist < 0.001) cleanPoints = cleanPoints.slice(0, -1);
                        }
                        e.points = generateCatmullRomPoints(cleanPoints, 50, isClosed);
                        e.closed = isClosed;
                    } else if (e.controlPoints && e.controlPoints.length >= degree + 1) {
                        e.points = generateBSplinePoints(e.controlPoints, e.knots, degree, isClosed, isPeriodic, 600);
                        e.closed = isClosed;
                    } else if (e.points && e.points.length >= 2) {
                        e.points = generateCatmullRomPoints(e.points, 50, isClosed);
                        e.closed = isClosed;
                    }
                }
            });
            
            console.log('è§£æå®Œäº†:', entities.length, 'ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£');
            
            currentEntities = entities;
            document.getElementById('fileInfo').textContent = filename;
            
            // UIã‚’åˆ‡ã‚Šæ›¿ãˆ
            document.getElementById('dropZone').style.display = 'none';
            document.getElementById('dxfCanvas').style.display = 'block';
            document.getElementById('canvasStatus').style.display = 'flex';

            // ãƒ„ãƒ¼ãƒ«ãƒ‘ã‚¹è¨ˆç®—
            calculateToolpath();
            
            // è¡¨ç¤ºæ›´æ–°
            resetView();
            drawDXF();
            calculateEstimate();
        }

        // ãƒ„ãƒ¼ãƒ«ãƒ‘ã‚¹è¨ˆç®—
        function calculateToolpath() {
            let totalLength = 0;
            let holeCount = 0;
            let lineCount = 0;
            let arcCount = 0;
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            currentEntities.forEach(entity => {
                // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹æ›´æ–°
                const updateBounds = (x, y) => {
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                };

                switch (entity.type) {
                    case 'LINE':
                        if (entity.x1 !== undefined && entity.x2 !== undefined) {
                            const length = Math.sqrt(
                                Math.pow(entity.x2 - entity.x1, 2) + 
                                Math.pow(entity.y2 - entity.y1, 2)
                            );
                            totalLength += length;
                            lineCount++;
                            updateBounds(entity.x1, entity.y1);
                            updateBounds(entity.x2, entity.y2);
                        }
                        break;

                    case 'CIRCLE':
                        if (entity.radius) {
                            totalLength += 2 * Math.PI * entity.radius;
                            holeCount++;
                            arcCount++;
                            updateBounds(entity.x1 - entity.radius, entity.y1 - entity.radius);
                            updateBounds(entity.x1 + entity.radius, entity.y1 + entity.radius);
                        }
                        break;

                    case 'ARC':
                        if (entity.radius) {
                            let startAngle = (entity.startAngle || 0) * Math.PI / 180;
                            let endAngle = (entity.endAngle || 360) * Math.PI / 180;
                            if (endAngle < startAngle) endAngle += 2 * Math.PI;
                            const arcLength = entity.radius * (endAngle - startAngle);
                            totalLength += arcLength;
                            arcCount++;
                            // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã¯ç°¡æ˜“çš„ã«å††ã§è¨ˆç®—
                            updateBounds(entity.x1 - entity.radius, entity.y1 - entity.radius);
                            updateBounds(entity.x1 + entity.radius, entity.y1 + entity.radius);
                        }
                        break;

                    case 'LWPOLYLINE':
                    case 'POLYLINE':
                        if (entity.points && entity.points.length > 1) {
                            for (let j = 0; j < entity.points.length - 1; j++) {
                                const p1 = entity.points[j];
                                const p2 = entity.points[j + 1];
                                const length = Math.sqrt(
                                    Math.pow(p2.x - p1.x, 2) + 
                                    Math.pow(p2.y - p1.y, 2)
                                );
                                totalLength += length;
                                updateBounds(p1.x, p1.y);
                            }
                            // æœ€å¾Œã®ç‚¹
                            const lastPt = entity.points[entity.points.length - 1];
                            updateBounds(lastPt.x, lastPt.y);
                            
                            // é–‰ã˜ã¦ã„ã‚‹å ´åˆ
                            if (entity.closed && entity.points.length > 2) {
                                const first = entity.points[0];
                                const last = entity.points[entity.points.length - 1];
                                totalLength += Math.sqrt(
                                    Math.pow(first.x - last.x, 2) + 
                                    Math.pow(first.y - last.y, 2)
                                );
                            }
                            lineCount++;
                        }
                        break;

                    case 'SPLINE':
                        if (entity.points && entity.points.length > 1) {
                            for (let j = 0; j < entity.points.length - 1; j++) {
                                const p1 = entity.points[j];
                                const p2 = entity.points[j + 1];
                                const length = Math.sqrt(
                                    Math.pow(p2.x - p1.x, 2) + 
                                    Math.pow(p2.y - p1.y, 2)
                                );
                                totalLength += length;
                                updateBounds(p1.x, p1.y);
                            }
                            arcCount++;
                        }
                        break;
                }
            });

            // çµæœã‚’ä¿å­˜
            toolpathInfo = {
                totalLength: totalLength,
                holeCount: holeCount,
                lineCount: lineCount,
                arcCount: arcCount,
                boundingBox: {
                    minX: minX === Infinity ? 0 : minX,
                    maxX: maxX === -Infinity ? 0 : maxX,
                    minY: minY === Infinity ? 0 : minY,
                    maxY: maxY === -Infinity ? 0 : maxY
                }
            };

            // UIæ›´æ–°
            document.getElementById('totalLength').textContent = Math.round(toolpathInfo.totalLength).toLocaleString();
            document.getElementById('holeCount').textContent = toolpathInfo.holeCount;
            document.getElementById('lineCount').textContent = toolpathInfo.lineCount;
            document.getElementById('arcCount').textContent = toolpathInfo.arcCount;
            
            const width = Math.round(toolpathInfo.boundingBox.maxX - toolpathInfo.boundingBox.minX);
            const height = Math.round(toolpathInfo.boundingBox.maxY - toolpathInfo.boundingBox.minY);
            document.getElementById('boundingBox').textContent = `${width} Ã— ${height}`;
            document.getElementById('entityCount').textContent = `ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£: ${currentEntities.length}`;

            // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã«åŸºã¥ã„ã¦ç´ æã‚µã‚¤ã‚ºã‚’è‡ªå‹•è¨­å®š
            if (width > 0 && height > 0) {
                document.getElementById('materialWidth').value = Math.ceil(width / 10) * 10 + 20;
                document.getElementById('materialHeight').value = Math.ceil(height / 10) * 10 + 20;
            }
        }

        // è¦‹ç©ã‚‚ã‚Šãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒ
        let estimateData = {};

        // è¦‹ç©ã‚‚ã‚Šè¨ˆç®—
        function calculateEstimate() {
            const materialType = document.getElementById('materialType').value;
            const thickness = parseFloat(document.getElementById('thickness').value) || 0;
            const materialPrice = parseFloat(document.getElementById('materialPrice').value) || 0;
            const materialWidth = parseFloat(document.getElementById('materialWidth').value) || 0;
            const materialHeight = parseFloat(document.getElementById('materialHeight').value) || 0;
            
            const cncHourlyRate = parseFloat(document.getElementById('cncHourlyRate').value) || 0;
            const camCost = parseFloat(document.getElementById('camCost').value) || 0;
            const setupCost = parseFloat(document.getElementById('setupCost').value) || 0;
            
            const machiningTime = parseFloat(document.getElementById('machiningTime').value) || 0;
            const camManDays = parseFloat(document.getElementById('camManDays').value) || 0;
            const finishingManDays = parseFloat(document.getElementById('finishingManDays').value) || 0;
            const finishingRate = parseFloat(document.getElementById('finishingRate').value) || 0;

            // ç´ æè²»è¨ˆç®—ï¼ˆæšæ•°ãƒ™ãƒ¼ã‚¹ï¼‰
            const sheetArea = 910 * 1820; // 3x6æ¿ (mmÂ²)
            const partArea = materialWidth * materialHeight;
            const sheetsNeeded = Math.ceil(partArea / sheetArea) || 1;
            const materialCost = sheetsNeeded * materialPrice;

            // CNCåŠ å·¥è²»è¨ˆç®—
            const cncCost = machiningTime * cncHourlyRate;

            // CAMãƒ‡ãƒ¼ã‚¿ä½œæˆè²»
            const camDataCost = camManDays * camCost;

            // ä»•ä¸Šã’è²»ï¼ˆãƒãƒªå–ã‚Šç ”ç£¨ï¼‰
            const finishingCost = finishingManDays * finishingRate;

            // åˆè¨ˆï¼ˆç¨åˆ¥ï¼‰
            const subtotal = materialCost + cncCost + camDataCost + finishingCost + setupCost;
            const tax = Math.round(subtotal * 0.1);
            const total = subtotal + tax;

            // ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
            estimateData = {
                materialType,
                materialName: materialNames[materialType] || materialType,
                thickness,
                materialPrice,
                materialWidth,
                materialHeight,
                sheetsNeeded,
                materialCost,
                cncHourlyRate,
                machiningTime,
                cncCost,
                camCost,
                camManDays,
                camDataCost,
                finishingRate,
                finishingManDays,
                finishingCost,
                setupCost,
                subtotal,
                tax,
                total
            };

            // UIæ›´æ–°
            document.getElementById('materialCost').textContent = `Â¥${Math.round(materialCost).toLocaleString()}`;
            document.getElementById('cncCost').textContent = `Â¥${Math.round(cncCost).toLocaleString()}`;
            document.getElementById('camDataCost').textContent = `Â¥${Math.round(camDataCost).toLocaleString()}`;
            document.getElementById('finishingCost').textContent = `Â¥${Math.round(finishingCost).toLocaleString()}`;
            document.getElementById('setupCostDisplay').textContent = `Â¥${Math.round(setupCost).toLocaleString()}`;
            document.getElementById('subtotalDisplay').textContent = `Â¥${Math.round(subtotal).toLocaleString()}`;
            document.getElementById('totalEstimate').textContent = `Â¥${Math.round(subtotal).toLocaleString()}`;
            document.getElementById('totalWithTax').textContent = `Â¥${Math.round(total).toLocaleString()}`;
        }

        // ç´ æãƒ—ãƒªã‚»ãƒƒãƒˆæ›´æ–°
        function updateMaterialPreset() {
            const materialType = document.getElementById('materialType').value;
            const price = materialPricePreset[materialType];
            if (price) {
                document.getElementById('materialPrice').value = price;
            }
        }

        // ã‚­ãƒ£ãƒ³ãƒã‚¹è¨­å®š
        function setupCanvas() {
            const canvas = document.getElementById('dxfCanvas');
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                zoomLevel *= delta;
                zoomLevel = Math.max(0.1, Math.min(10, zoomLevel));
                document.getElementById('zoomStatus').textContent = `ã‚ºãƒ¼ãƒ : ${Math.round(zoomLevel * 100)}%`;
                drawDXF();
            });

            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 2) {
                    isPanning = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    canvas.style.cursor = 'grabbing';
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    const dx = e.clientX - lastMouseX;
                    const dy = e.clientY - lastMouseY;
                    panX += dx;
                    panY += dy;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    drawDXF();
                }
            });

            canvas.addEventListener('mouseup', () => {
                isPanning = false;
                canvas.style.cursor = 'crosshair';
            });

            canvas.addEventListener('mouseleave', () => {
                isPanning = false;
                canvas.style.cursor = 'crosshair';
            });

            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            window.addEventListener('resize', () => {
                if (currentEntities.length > 0) {
                    drawDXF();
                }
            });
        }

        // ãƒ†ãƒ¼ãƒã«å¿œã˜ãŸæç”»è‰²ã‚’å–å¾—
        function getThemeColors() {
            const isLight = currentTheme === 'light';
            return {
                background: isLight ? '#ffffff' : '#1a1a2e',
                entity: isLight ? '#0d9488' : '#14b8a6',
                circle: isLight ? '#ea580c' : '#f97316',
                spline: isLight ? '#9333ea' : '#a855f7',
                grid: isLight ? 'rgba(203, 213, 225, 0.5)' : 'rgba(71, 85, 105, 0.3)'
            };
        }

        // DXFæç”»
        function drawDXF() {
            const canvas = document.getElementById('dxfCanvas');
            const wrapper = document.getElementById('canvasWrapper');
            const ctx = canvas.getContext('2d');
            const colors = getThemeColors();
            
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight - 100; // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ã®åˆ†

            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (currentEntities.length === 0) return;

            // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹
            const bb = toolpathInfo.boundingBox;
            const dataWidth = bb.maxX - bb.minX || 1;
            const dataHeight = bb.maxY - bb.minY || 1;

            // ã‚¹ã‚±ãƒ¼ãƒ«ã¨ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—
            const padding = 60;
            const scaleX = (canvas.width - padding * 2) / dataWidth;
            const scaleY = (canvas.height - padding * 2) / dataHeight;
            currentScale = Math.min(scaleX, scaleY) * zoomLevel;
            
            currentOffsetX = canvas.width / 2 - (bb.minX + dataWidth / 2) * currentScale + panX;
            currentOffsetY = canvas.height / 2 + (bb.minY + dataHeight / 2) * currentScale + panY;

            // ã‚°ãƒªãƒƒãƒ‰æç”»
            if (showGrid) {
                drawGrid(ctx, canvas.width, canvas.height, colors);
            }

            // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£æç”»
            ctx.strokeStyle = colors.entity;
            ctx.lineWidth = 1.5;

            currentEntities.forEach(entity => {
                ctx.beginPath();

                switch (entity.type) {
                    case 'LINE':
                        if (entity.x1 !== undefined && entity.x2 !== undefined) {
                            const x1 = entity.x1 * currentScale + currentOffsetX;
                            const y1 = -entity.y1 * currentScale + currentOffsetY;
                            const x2 = entity.x2 * currentScale + currentOffsetX;
                            const y2 = -entity.y2 * currentScale + currentOffsetY;
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                        }
                        break;

                    case 'CIRCLE':
                        if (entity.radius) {
                            const cx = entity.x1 * currentScale + currentOffsetX;
                            const cy = -entity.y1 * currentScale + currentOffsetY;
                            const r = entity.radius * currentScale;
                            ctx.arc(cx, cy, r, 0, Math.PI * 2);
                            ctx.strokeStyle = colors.circle;
                        }
                        break;

                    case 'ARC':
                        if (entity.radius) {
                            const cx = entity.x1 * currentScale + currentOffsetX;
                            const cy = -entity.y1 * currentScale + currentOffsetY;
                            const r = entity.radius * currentScale;
                            const startAngle = -(entity.startAngle || 0) * Math.PI / 180;
                            const endAngle = -(entity.endAngle || 360) * Math.PI / 180;
                            ctx.arc(cx, cy, r, startAngle, endAngle, true);
                        }
                        break;

                    case 'LWPOLYLINE':
                    case 'POLYLINE':
                        if (entity.points && entity.points.length > 1) {
                            const first = entity.points[0];
                            ctx.moveTo(
                                first.x * currentScale + currentOffsetX,
                                -first.y * currentScale + currentOffsetY
                            );
                            for (let j = 1; j < entity.points.length; j++) {
                                const pt = entity.points[j];
                                ctx.lineTo(
                                    pt.x * currentScale + currentOffsetX,
                                    -pt.y * currentScale + currentOffsetY
                                );
                            }
                            if (entity.closed) {
                                ctx.closePath();
                            }
                        }
                        break;

                    case 'SPLINE':
                        if (entity.points && entity.points.length > 1) {
                            ctx.strokeStyle = colors.spline;
                            const first = entity.points[0];
                            ctx.moveTo(
                                first.x * currentScale + currentOffsetX,
                                -first.y * currentScale + currentOffsetY
                            );
                            for (let j = 1; j < entity.points.length; j++) {
                                const pt = entity.points[j];
                                ctx.lineTo(
                                    pt.x * currentScale + currentOffsetX,
                                    -pt.y * currentScale + currentOffsetY
                                );
                            }
                        }
                        break;
                }

                ctx.stroke();
                ctx.strokeStyle = colors.entity;
            });
        }

        // ã‚°ãƒªãƒƒãƒ‰æç”»
        function drawGrid(ctx, width, height, colors) {
            ctx.strokeStyle = colors.grid;
            ctx.lineWidth = 0.5;

            const gridSize = 50 * zoomLevel;
            const startX = currentOffsetX % gridSize;
            const startY = currentOffsetY % gridSize;

            ctx.beginPath();
            for (let x = startX; x < width; x += gridSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
            }
            for (let y = startY; y < height; y += gridSize) {
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
            }
            ctx.stroke();
        }

        // ã‚ºãƒ¼ãƒ æ“ä½œ
        function zoomIn() {
            zoomLevel *= 1.2;
            zoomLevel = Math.min(10, zoomLevel);
            document.getElementById('zoomStatus').textContent = `ã‚ºãƒ¼ãƒ : ${Math.round(zoomLevel * 100)}%`;
            drawDXF();
        }

        function zoomOut() {
            zoomLevel *= 0.8;
            zoomLevel = Math.max(0.1, zoomLevel);
            document.getElementById('zoomStatus').textContent = `ã‚ºãƒ¼ãƒ : ${Math.round(zoomLevel * 100)}%`;
            drawDXF();
        }

        function resetView() {
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;
            document.getElementById('zoomStatus').textContent = 'ã‚ºãƒ¼ãƒ : 100%';
            drawDXF();
        }

        function toggleGrid() {
            showGrid = !showGrid;
            drawDXF();
        }

        // è¦‹ç©æ›¸å‡ºåŠ›ï¼ˆHTMLå½¢å¼ï¼‰
        function exportEstimate() {
            const today = new Date();
            const dateStr = `${today.getFullYear()}${String(today.getMonth() + 1).padStart(2, '0')}${String(today.getDate()).padStart(2, '0')}`;
            const projectName = currentFilename ? currentFilename.replace('.dxf', '') : 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå';
            
            const d = estimateData;
            const fmt = (n) => Math.round(n).toLocaleString();
            
            const html = `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>æ¦‚ç®—è¦‹ç©ã‚‚ã‚Š - ${projectName}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif; padding: 40px; background: #fff; color: #333; font-size: 12px; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { text-align: center; font-size: 20px; font-weight: normal; border: 2px solid #333; padding: 10px; margin-bottom: 30px; }
        .header-info { display: flex; justify-content: space-between; margin-bottom: 20px; }
        .header-left { flex: 1; }
        .header-right { text-align: right; }
        .header-row { margin-bottom: 8px; }
        .header-label { font-weight: bold; }
        .amount-box { background: #fff; padding: 10px; margin-top: 10px; }
        .amount-row { display: flex; justify-content: flex-end; gap: 20px; margin: 5px 0; }
        .amount-label { }
        .amount-value { font-weight: bold; font-size: 16px; }
        .amount-value.red { color: #c00; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        th { background: #f5f5f5; font-weight: normal; }
        .text-right { text-align: right; }
        .text-center { text-align: center; }
        .section-header { background: #e0e0e0; font-weight: bold; }
        .category-header { background: #f9f9f9; padding-left: 20px; }
        .item-row td:first-child { padding-left: 40px; }
        .subtotal-row { background: #fafafa; font-weight: bold; }
        .notes { margin-top: 30px; padding: 15px; border: 1px solid #ccc; }
        .notes h3 { font-size: 12px; margin-bottom: 10px; }
        .notes ul { margin-left: 20px; }
        .notes li { margin: 5px 0; }
        @media print { body { padding: 20px; } }
    </style>
</head>
<body>
    <div class="container">
        <h1>æ¦‚ç®—è¦‹ç©ã‚‚ã‚Š</h1>
        
        <div class="header-info">
            <div class="header-left">
                <div class="header-row"><span class="header-label">ä»¶åï¼š</span> ${projectName}</div>
            </div>
            <div class="header-right">
                <div class="header-row">${dateStr}</div>
                <div class="amount-box">
                    <div class="amount-row">
                        <span class="amount-label">ãŠè¦‹ç©ã‚Šé‡‘é¡ï¼š</span>
                        <span class="amount-value">Â¥${fmt(d.subtotal)}</span>
                        <span class="amount-value red">ï¼ˆç¨åˆ¥ï¼‰</span>
                    </div>
                    <div class="amount-row">
                        <span></span>
                        <span class="amount-value">Â¥${fmt(d.total)}</span>
                        <span class="amount-value red">ï¼ˆç¨è¾¼ï¼‰</span>
                    </div>
                </div>
            </div>
        </div>
        
        <table>
            <thead>
                <tr>
                    <th style="width: 45%"></th>
                    <th class="text-right" style="width: 15%">å˜ä¾¡</th>
                    <th class="text-right" style="width: 10%">æ•°é‡</th>
                    <th class="text-center" style="width: 10%">å˜ä½</th>
                    <th class="text-right" style="width: 20%">ä¾¡æ ¼</th>
                </tr>
            </thead>
            <tbody>
                <tr class="section-header">
                    <td colspan="5">CNCåŠ å·¥</td>
                </tr>
                <tr class="category-header">
                    <td colspan="5">ææ–™è²»</td>
                </tr>
                <tr class="item-row">
                    <td>${d.materialName} ${d.thickness}mm</td>
                    <td class="text-right">${fmt(d.materialPrice)}</td>
                    <td class="text-right">${d.sheetsNeeded}</td>
                    <td class="text-center">æš</td>
                    <td class="text-right">${fmt(d.materialCost)}</td>
                </tr>
                <tr class="category-header">
                    <td colspan="5">ç‰¹æ®Šæ¥­å‹™å§”è¨—è²»</td>
                </tr>
                <tr class="item-row">
                    <td>åˆ‡å‰ŠåŠ å·¥è²»ï¼ˆCNCã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼äººä»¶è²»è¾¼ï¼‰</td>
                    <td class="text-right">${fmt(d.cncHourlyRate)}</td>
                    <td class="text-right">${d.machiningTime}</td>
                    <td class="text-center">æ™‚é–“</td>
                    <td class="text-right">${fmt(d.cncCost)}</td>
                </tr>
                <tr class="item-row">
                    <td>åŠ å·¥ãƒ‡ãƒ¼ã‚¿ä½œæˆè²»ï¼ˆå…±é€šï¼‰</td>
                    <td class="text-right">${fmt(d.camCost)}</td>
                    <td class="text-right">${d.camManDays}</td>
                    <td class="text-center">äººå·¥</td>
                    <td class="text-right">${fmt(d.camDataCost)}</td>
                </tr>
                <tr class="category-header">
                    <td colspan="5">ä¸€èˆ¬äººä»¶è²»</td>
                </tr>
                <tr class="item-row">
                    <td>ä»•ä¸Šè²»ï¼ˆãƒãƒªå–ã‚Šç ”ç£¨ï¼‰</td>
                    <td class="text-right">${fmt(d.finishingRate)}</td>
                    <td class="text-right">${d.finishingManDays}</td>
                    <td class="text-center">äººå·¥</td>
                    <td class="text-right">${fmt(d.finishingCost)}</td>
                </tr>
                <tr class="item-row">
                    <td>ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—è²»</td>
                    <td class="text-right">${fmt(d.setupCost)}</td>
                    <td class="text-right">1</td>
                    <td class="text-center">å¼</td>
                    <td class="text-right">${fmt(d.setupCost)}</td>
                </tr>
                <tr class="subtotal-row">
                    <td colspan="4">å°è¨ˆï¼ˆç¨åˆ¥ï¼‰</td>
                    <td class="text-right">${fmt(d.subtotal)}</td>
                </tr>
            </tbody>
        </table>
        
        <div class="notes">
            <h3>å‚™è€ƒ</h3>
            <ul>
                <li>è©³ç´°è¨­è¨ˆã«ã‚ˆã‚Šé‡‘é¡ãŒå¤‰å‹•ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™</li>
                <li>ä»•ä¸Šã’ä»•æ§˜ç­‰ã¯ä»Šå¾Œè©°ã‚ã¦ã„ãæ®µéšã§é‡‘é¡ã®VEç­‰ãŒå¯èƒ½ã§ã™ãŒã–ã£ãã‚Šã¨è¦‹è¾¼ã‚“ã§ã„ã¾ã™ã€‚</li>
                <li>ç ”ç£¨ã¯ç³¸é¢åŠ å·¥ã¨ã—ã¦ã„ã¾ã™ã€‚RåŠ å·¥ã®å ´åˆãªã©ã¯é‡‘é¡ãŒå¤‰å‹•ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™</li>
                <li>è¼¸é€è²»ã¯å«ã‚“ã§ãŠã‚Šã¾ã›ã‚“ã€‚</li>
                <li>æœ¬è¦‹ç©ã‚‚ã‚Šã¯æ¦‚ç®—ã®é‡‘é¡ã§ã™ã€‚</li>
            </ul>
        </div>
        
        <div style="margin-top: 30px; font-size: 10px; color: #666;">
            <p>ãƒ„ãƒ¼ãƒ«ãƒ‘ã‚¹æƒ…å ±: åˆ‡å‰Šç·é•· ${fmt(toolpathInfo.totalLength)}mm / ç©´åŠ å·¥æ•° ${toolpathInfo.holeCount} / ç›´ç·šæ•° ${toolpathInfo.lineCount} / æ›²ç·šæ•° ${toolpathInfo.arcCount}</p>
            <p>ã‚µã‚¤ã‚º: ${d.materialWidth} Ã— ${d.materialHeight} mm / æ¿åš: ${d.thickness}mm</p>
        </div>
    </div>
</body>
</html>`;

            // HTMLãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦å‡ºåŠ›
            const blob = new Blob([html], { type: 'text/html;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `è¦‹ç©æ›¸_${projectName}_${dateStr}.html`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ãƒªã‚»ãƒƒãƒˆ
        function resetAll() {
            currentEntities = [];
            toolpathInfo = {
                totalLength: 0,
                holeCount: 0,
                lineCount: 0,
                arcCount: 0,
                boundingBox: { minX: 0, maxX: 0, minY: 0, maxY: 0 }
            };
            
            document.getElementById('dropZone').style.display = 'flex';
            document.getElementById('dxfCanvas').style.display = 'none';
            document.getElementById('canvasStatus').style.display = 'none';
            document.getElementById('fileInfo').textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«æœªé¸æŠ';
            
            document.getElementById('totalLength').textContent = '0';
            document.getElementById('holeCount').textContent = '0';
            document.getElementById('lineCount').textContent = '0';
            document.getElementById('arcCount').textContent = '0';
            document.getElementById('boundingBox').textContent = '0 Ã— 0';
            
            calculateEstimate();
        }
    </script>
</body>
</html>

